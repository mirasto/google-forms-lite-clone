import type { Resolvers, ResolverFn } from './types.js';
import type { Context, Answer, Question, Response } from './types.js';
import * as factories from './factories.js';
import { createFormSchema, submitResponseSchema } from './validation.js';
import { GraphQLError } from 'graphql';
import { z, ZodError, type ZodType } from 'zod';

import { withFilter } from 'graphql-subscriptions';

const validate = <S extends ZodType>(schema: S, data: unknown): z.infer<S> => {
  try {
    return schema.parse(data);
  } catch (error) {
    if (error instanceof ZodError) {
      const issues = error.issues.map(issue => `${issue.path.join('.')}: ${issue.message}`).join('; ');
      throw new GraphQLError(issues, { extensions: { code: 'BAD_USER_INPUT' } });
    }
    throw error;
  }
};

export const resolvers: Resolvers = {
  Query: {
    forms: (_parent, _args, { store }) => store.getForms(),
    form: (_parent, { id }, { store }) => store.getForm(id) ?? null,
    responses: (_parent, { formId }, { store }) => store.getResponses(formId),
  },

  Mutation: {
    createForm: (_parent, args, { store }) => {
      const validatedArgs = validate(createFormSchema, args);
      const { title, description, questions } = validatedArgs;
      
      // Strict mapping to ensure type safety and remove 'any' cast
      // We explicitly map Zod-validated input to our internal Question model
      const mappedQuestions: Question[] = questions.map(question => ({
        ...question,
        id: '', // Will be generated by factory
        options: question.options?.map(option => ({
          ...option,
          id: option.id ?? '' // Will be generated by factory if empty
        })) ?? undefined
      }));

      const newForm = factories.createForm(title, description, mappedQuestions); 
      
      store.addForm(newForm);
      return newForm;
    },

    submitResponse: (_parent, args, context) => {
      const { store } = context;
      const validatedArgs = validate(submitResponseSchema, args);
      const { formId, answers } = validatedArgs;

      const targetForm = store.getForm(formId);
      if (!targetForm) throw new GraphQLError('Form not found', { extensions: { code: 'NOT_FOUND' } });

      const answersMap = new Map(answers.map(answer => [answer.questionId, answer]));
      const validAnswers: Answer[] = [];
      
      targetForm.questions.forEach((question) => {
        const answerInput = answersMap.get(question.id);
        const hasValue = answerInput?.values.some(value => value.trim() !== '') ?? false;

        if (question.required && !hasValue) {
          throw new GraphQLError(`Question "${question.text}" is required`, { extensions: { code: 'BAD_USER_INPUT', field: question.id } });
        }


        if (hasValue && (question.type === 'MULTIPLE_CHOICE' || question.type === 'CHECKBOX') && question.options && answerInput) {
          const allowedOptions = new Set(question.options.map(option => option.value));
          answerInput.values.forEach(value => {
            if (!allowedOptions.has(value)) {
              throw new GraphQLError(`Invalid option "${value}" for question "${question.text}"`, { extensions: { code: 'BAD_USER_INPUT' } });
            }
          });
        }


        if (answerInput) {
          validAnswers.push({
            questionId: question.id,
            values: answerInput.values
          });
        }
      });

      const newResponse = factories.createResponse(formId, validAnswers);
      store.addResponse(newResponse);
      
      // Publish event
      context.pubsub.publish('RESPONSE_ADDED', { responseAdded: newResponse });
      
      return newResponse;
    },
  },

  Subscription: {
    responseAdded: {
      subscribe: withFilter(
        (_parent: unknown, _args: unknown, context: Context | undefined) => {
          if (!context) {
            throw new GraphQLError('Context is missing', { extensions: { code: 'INTERNAL_SERVER_ERROR' } });
          }
          return context.pubsub.asyncIterator<Response>(['RESPONSE_ADDED']);
        },
        (payload: unknown, variables: unknown) => {
          const typedPayload = payload as { responseAdded: Response };
          const typedVariables = variables as { formId: string };
          return typedPayload.responseAdded.formId === typedVariables.formId;
        }
      ) as unknown as ResolverFn<AsyncIterator<Response>, {}, { formId: string }>,
    },
  },
};
